#
# ~/.zshrc.tmpl - Managed by Chezmoi
#
# This file is a template and will be rendered by chezmoi apply
# Cross-platform support for macOS, Linux, and Windows (WSL)
#
# Generated for: {{ .chezmoi.os }}/{{ .chezmoi.arch }}
# Generated on: {{ now | date "2006-01-02 15:04:05" }}
#

# Enable Powerlevel10k instant prompt (if available)
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# Path to your Oh My Zsh installation
export ZSH="$HOME/.oh-my-zsh"
export EDITOR="micro"

# Set theme to powerlevel10k
ZSH_THEME="powerlevel10k/powerlevel10k"

#
# ----- Plugins -----
#
plugins=(
  git
  {{- if eq .chezmoi.os "darwin" }}
  macos
  brew
  {{- else if eq .chezmoi.os "linux" }}
  systemd
  {{- else if eq .chezmoi.os "windows" }}
  wsl
  {{- end }}
  zsh-completions
  zsh-autosuggestions
  zsh-syntax-highlighting
  zsh-history-substring-search
)

# Load Oh My Zsh
if [[ -f "$ZSH/oh-my-zsh.sh" ]]; then
  source "$ZSH/oh-my-zsh.sh"
fi

# Load Powerlevel10k config (if available)
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

#
# ----- History Setup -----
#
HISTFILE="$HOME/.zhistory"
SAVEHIST=1000
HISTSIZE=999
setopt share_history
setopt hist_expire_dups_first
setopt hist_ignore_dups
setopt hist_verify

# History navigation with arrow keys
bindkey '^[[A' history-search-backward
bindkey '^[[B' history-search-forward

#
# ----- Platform-Specific Tool Configuration -----
#
{{- if eq .chezmoi.os "linux" }}
# Linux (Fedora/Ubuntu) - using fdfind and batcat
alias bat="batcat"
export FD_COMMAND="fdfind"
export BAT_COMMAND="batcat"
{{- else if eq .chezmoi.os "darwin" }}
# macOS - using fd and bat
export FD_COMMAND="fd"
export BAT_COMMAND="bat"
{{- else if eq .chezmoi.os "windows" }}
# Windows (WSL) - using fd.exe and bat.exe
export FD_COMMAND="fd.exe"
export BAT_COMMAND="bat.exe"
{{- end }}

#
# ----- Enhanced FZF Setup with cd ** functionality (fzf 0.29 compatible) -----
#

if command -v fzf &> /dev/null; then
  # Configure fzf to use fd instead of find
  if command -v $FD_COMMAND &> /dev/null; then
    export FZF_DEFAULT_COMMAND="$FD_COMMAND --hidden --strip-cwd-prefix --exclude .git"
    export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
    export FZF_ALT_C_COMMAND="$FD_COMMAND --type=d --hidden --strip-cwd-prefix --exclude .git"
    
    # Use fd for path completion (enables ** completion)
    _fzf_compgen_path() { 
      $FD_COMMAND --hidden --exclude .git . "$1" 
    }
    
    # Use fd for directory completion (enables cd **<Tab>)
    _fzf_compgen_dir() { 
      $FD_COMMAND --type=d --hidden --exclude .git . "$1" 
    }
  fi

  # Enhanced FZF theme and options
  fg="#CBE0F0"
  bg="#011628"
  bg_highlight="#143652"
  purple="#B388FF"
  blue="#06BCE4"
  cyan="#2CF9ED"

  export FZF_DEFAULT_OPTS="--color=fg:${fg},bg:${bg},hl:${purple},fg+:${fg},bg+:${bg_highlight},hl+:${purple},info:${blue},prompt:${cyan},pointer:${cyan},marker:${cyan},spinner:${cyan},header:${cyan} --height 50% --layout=default --border --cycle --bind 'ctrl-/:change-preview-window(down|hidden|)'"

  # Enhanced preview setup with eza and bat
  if command -v eza &> /dev/null && command -v $BAT_COMMAND &> /dev/null; then
    show_file_or_dir_preview="if [ -d {} ]; then eza --tree --color=always {} | head -200; else $BAT_COMMAND -n --color=always --line-range :500 {}; fi"
    
    export FZF_CTRL_T_OPTS="--preview '$show_file_or_dir_preview'"
    export FZF_ALT_C_OPTS="--preview 'eza --tree --color=always {} | head -200'"
    
    # Enhanced completion with preview for different commands
    _fzf_comprun() {
      local command=$1
      shift
      case "$command" in
        cd)           fzf --preview 'eza --tree --color=always {} | head -200' "$@" ;;
        export|unset) fzf --preview "eval 'echo \${$1}'"         "$@" ;;
        ssh)          fzf --preview 'dig {}'                   "$@" ;;
        *)            fzf --preview "$show_file_or_dir_preview" "$@" ;;
      esac
    }
  fi

  # Load fzf key bindings and completion (CRITICAL for cd ** functionality)
  # Method 1: Try to source the completion and key-bindings files directly
  
  {{- if eq .chezmoi.os "darwin" }}
  # macOS paths (Homebrew)
  if [[ -f /opt/homebrew/share/fzf/shell/completion.zsh ]]; then
    source /opt/homebrew/share/fzf/shell/completion.zsh
  elif [[ -f /usr/local/share/fzf/shell/completion.zsh ]]; then
    source /usr/local/share/fzf/shell/completion.zsh
  fi
  
  if [[ -f /opt/homebrew/share/fzf/shell/key-bindings.zsh ]]; then
    source /opt/homebrew/share/fzf/shell/key-bindings.zsh
  elif [[ -f /usr/local/share/fzf/shell/key-bindings.zsh ]]; then
    source /usr/local/share/fzf/shell/key-bindings.zsh
  fi
  {{- else if eq .chezmoi.os "linux" }}
  # Linux paths
  if [[ -f /usr/share/fzf/completion.zsh ]]; then
    source /usr/share/fzf/completion.zsh
  elif [[ -f /usr/share/zsh/site-functions/_fzf ]]; then
    # Some distributions install differently
    autoload -U _fzf
  fi
  
  if [[ -f /usr/share/fzf/key-bindings.zsh ]]; then
    source /usr/share/fzf/key-bindings.zsh
  fi
  {{- end }}
  
  # Method 2: Fallback to ~/.fzf.zsh if it exists
  if [[ -f ~/.fzf.zsh ]]; then
    source ~/.fzf.zsh
  fi
  
  # Method 3: Manual setup if no completion files found (last resort)
  if ! typeset -f _fzf_completion &> /dev/null; then
    # Setup manual completion trigger for **
    __fzf_generic_path_completion() {
      local base lbuf cmd compgen fzf_opts suffix tail dir leftover matches
      base=$1
      lbuf=$2
      cmd=$3
      compgen=$4
      fzf_opts=$5
      suffix=$6
      tail=$7

      setopt localoptions noshwordsplit noksh_arrays noposixbuiltins
      
      eval "base=$base"
      [[ $base = *"/"* ]] && dir="$base"
      while [ 1 ]; do
        if [[ -z "$dir" ]] || [[ -d ${dir} ]]; then
          leftover=${base/#"$dir"}
          leftover=${leftover/#\/}
          [ -z "$dir" ] && dir='.'
          [ "$dir" != "/" ] && dir="${dir/%\//}"
          matches=$(eval "$compgen $(printf %q "$dir")" | FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} --reverse --bind=tab:down,btab:up $FZF_DEFAULT_OPTS $fzf_opts" fzf --query "$leftover" | while read item; do
            echo -n "${(q)item}$suffix "
          done)
          matches=${matches% }
          if [ -n "$matches" ]; then
            LBUFFER="$lbuf$matches$tail"
          fi
          zle reset-prompt
          break
        fi
        dir=$(dirname "$dir")
        dir=${dir%/}/
      done
    }

    _fzf_dir_completion() {
      __fzf_generic_path_completion "$1" "$2" _fzf_dir_completion \
        "$FZF_ALT_C_COMMAND" "$FZF_ALT_C_OPTS" "/" ""
    }

    _fzf_file_completion() {
      __fzf_generic_path_completion "$1" "$2" _fzf_path_completion \
        "$FZF_CTRL_T_COMMAND" "$FZF_CTRL_T_OPTS" "" ""
    }

    # Bind ** completion
    fzf-completion() {
      local tokens cmd prefix trigger tail matches lbuf d_cmds
      setopt localoptions noshwordsplit noksh_arrays noposixbuiltins

      # Tokenize the current line
      eval "tokens=(\${(z)LBUFFER})"
      [ ${#tokens} -lt 1 ] && zle ${fzf_default_completion:-expand-or-complete} && return

      cmd=$tokens[1]

      # Check for ** trigger
      if [[ "$LBUFFER" == *'**' ]]; then
        # Remove ** from the end
        lbuf=${LBUFFER%'**'}
        
        # Check if it's a directory completion command
        d_cmds=${FZF_COMPLETION_DIR_COMMANDS:-cd pushd rmdir}
        if [[ " $d_cmds " == *" $cmd "* ]]; then
          _fzf_dir_completion "" "$lbuf"
        else
          _fzf_file_completion "" "$lbuf"
        fi
        return
      fi

      # Fall back to default completion
      zle ${fzf_default_completion:-expand-or-complete}
    }

    # Setup widgets and bindings
    zle -N fzf-completion
    bindkey '^I' fzf-completion
    
    # Key bindings for Ctrl+T, Ctrl+R, Alt+C
    __fzf_select__() {
      local cmd="${FZF_CTRL_T_COMMAND:-"command find -L . -mindepth 1 \\( -path '*/\\.*' -o -fstype 'sysfs' -o -fstype 'devfs' -o -fstype 'devtmpfs' -o -fstype 'proc' \\) -prune -o -type f -print -o -type d -print -o -type l -print 2> /dev/null | cut -b3-"}"
      setopt localoptions pipefail no_aliases 2> /dev/null
      local item
      eval "$cmd" | FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} --reverse --bind=tab:down,btab:up $FZF_DEFAULT_OPTS $FZF_CTRL_T_OPTS" fzf -m "$@" | while read item; do
        echo -n "${(q)item} "
      done
      local ret=$?
      echo
      return $ret
    }

    fzf-file-widget() {
      LBUFFER="${LBUFFER}$(__fzf_select__)"
      local ret=$?
      zle reset-prompt
      return $ret
    }
    zle -N fzf-file-widget
    bindkey '^T' fzf-file-widget

    # History widget
    fzf-history-widget() {
      local selected num
      setopt localoptions noglobsubst noposixbuiltins pipefail no_aliases 2> /dev/null
      selected=( $(fc -rl 1 | FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} --reverse --bind=tab:down,btab:up $FZF_DEFAULT_OPTS $FZF_CTRL_R_OPTS" fzf --query="$LBUFFER" +m) )
      local ret=$?
      if [ -n "$selected" ]; then
        num=$selected[1]
        if [ -n "$num" ]; then
          zle vi-fetch-history -n $num
        fi
      fi
      zle reset-prompt
      return $ret
    }
    zle -N fzf-history-widget
    bindkey '^R' fzf-history-widget

    # Directory widget
    __fzf_cd__() {
      local cmd="${FZF_ALT_C_COMMAND:-"command find -L . -mindepth 1 \\( -path '*/\\.*' -o -fstype 'sysfs' -o -fstype 'devfs' -o -fstype 'devtmpfs' -o -fstype 'proc' \\) -prune -o -type d -print 2> /dev/null | cut -b3-"}"
      setopt localoptions pipefail no_aliases 2> /dev/null
      local dir="$(eval "$cmd" | FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} --reverse --bind=tab:down,btab:up $FZF_DEFAULT_OPTS $FZF_ALT_C_OPTS" fzf +m)"
      if [[ -n "$dir" ]]; then
        cd "$dir"
      fi
    }

    fzf-cd-widget() {
      __fzf_cd__
      local ret=$?
      zle reset-prompt
      return $ret
    }
    zle -N fzf-cd-widget
    bindkey '\ec' fzf-cd-widget  # Alt+C
  fi
fi

# Load fzf-git.sh if available
[ -f ~/fzf-git.sh/fzf-git.sh ] && source ~/fzf-git.sh/fzf-git.sh

#
# ----- Aliases -----
#
# Eza (better ls) - only if available
if command -v eza &> /dev/null; then
  alias l="eza --icons=always"
  alias ls="eza --icons=always"
  alias ll="eza -lg --icons=always"
  alias la="eza -lag --icons=always"
  alias lt="eza -lTg --icons=always"
  alias lt2="eza -lTg --level=2 --icons=always"
  alias lt3="eza -lTg --level=3 --icons=always"
  alias lta="eza -lTag --icons=always"
  alias lta2="eza -lTag --level=2 --icons=always"
  alias lta3="eza -lTag --level=3 --icons=always"
fi

# Zoxide (better cd) - only if available
if command -v zoxide &> /dev/null; then
  eval "$(zoxide init zsh --cmd cd)"
fi

# Bat theme
export BAT_THEME=1337


# Add local bin to PATH
export PATH="$PATH:$HOME/.local/bin"

#
# ----- Platform-Specific Runtime Environments -----
#

# Conda initialization
{{- $condaPath := "" }}
{{- if eq .chezmoi.os "darwin" }}
  {{- $condaPath = "$HOME/miniconda" }}
{{- else }}
  {{- $condaPath = "$HOME/miniconda3" }}
{{- end }}

if [ -f "{{ $condaPath }}/bin/conda" ]; then
  __conda_setup="$({{ $condaPath }}/bin/conda 'shell.zsh' 'hook' 2> /dev/null)"
  if [ $? -eq 0 ]; then
    eval "$__conda_setup"
  else
    if [ -f "{{ $condaPath }}/etc/profile.d/conda.sh" ]; then
      . "{{ $condaPath }}/etc/profile.d/conda.sh"
    else
      export PATH="{{ $condaPath }}/bin:$PATH"
    fi
  fi
  unset __conda_setup
fi

# NVM (Node Version Manager)
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"

{{- if eq .chezmoi.os "darwin" }}
# macOS-specific configurations

# Google Cloud SDK
if [ -f "$HOME/Downloads/google-cloud-sdk/path.zsh.inc" ]; then
  source "$HOME/Downloads/google-cloud-sdk/path.zsh.inc"
fi
if [ -f "$HOME/Downloads/google-cloud-sdk/completion.zsh.inc" ]; then
  source "$HOME/Downloads/google-cloud-sdk/completion.zsh.inc"
fi

# iTerm2 shell integration
if [[ -n $CURSOR_TRACE_ID ]]; then
  PROMPT_EOL_MARK=""
  test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"
  precmd() { print -Pn "\e]133;D;%?\a" }
  preexec() { print -Pn "\e]133;C;\a" }
fi

# Homebrew
if [[ -f "/opt/homebrew/bin/brew" ]]; then
  eval "$(/opt/homebrew/bin/brew shellenv)"
elif [[ -f "/usr/local/bin/brew" ]]; then
  eval "$(/usr/local/bin/brew shellenv)"
fi

{{- else if eq .chezmoi.os "linux" }}
# Linux-specific configurations

# Add snap to PATH if available
if [ -d "/snap/bin" ]; then
  export PATH="/snap/bin:$PATH"
fi

# Flatpak
if command -v flatpak &> /dev/null; then
  export XDG_DATA_DIRS="/var/lib/flatpak/exports/share:$HOME/.local/share/flatpak/exports/share:$XDG_DATA_DIRS"
fi

{{- else if eq .chezmoi.os "windows" }}
# Windows (WSL) specific configurations

# Windows PATH integration (if needed)
# export PATH="$PATH:/mnt/c/Windows/System32"

# WSL-specific aliases
alias explorer="explorer.exe"
alias code="code.exe"

{{- end }}

# Load any local customizations
[ -f ~/.zshrc.local ] && source ~/.zshrc.local
